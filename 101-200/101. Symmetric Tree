class Solution {
    public boolean isSymmetric(TreeNode root) {
        //如果根节点为空，要返回 true，烦！
        if(root == null){
            return true;
        }
        return DFS(root.left, root.right);
    }

    public boolean DFS(TreeNode leftChild, TreeNode rightChild){
        if (leftChild == null || rightChild == null){
            return leftChild == rightChild;
        }
        if (leftChild.val != rightChild.val){
            return false;
        }
        //判断一个节点的左孩子和另一个节点的右孩子是否相同
        return DFS(leftChild.left, rightChild.right) && DFS(leftChild.right, rightChild.left);
    }
}

// 用栈也行
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null){
            return true;
        }
        Stack<TreeNode> stack = new Stack<>();
        if (root.left != null){
            if (root.right == null){
                return false;
            }
            stack.push(root.left);
            stack.push(root.right);
        } else if (root.right != null){
            return false;
        }
        TreeNode left, right;
        while (!stack.isEmpty()){
            right = stack.pop();
            left = stack.pop();
            if (left.val != right.val){
                return false;
            }
            if (left.left != null){
                if (right.right == null){
                    return false;
                }
                stack.push(left.left);
                stack.push(right.right);
            } else if (right.right != null){
                return false;
            }
            if (left.right != null){
                if (right.left == null){
                    return false;
                }
                stack.push(left.right);
                stack.push(right.left);
            } else if (right.left != null){
                return false;
            }
        }
        return true;
    }
}